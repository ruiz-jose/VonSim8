import{_ as o,c,o as r,ag as d}from"./chunks/framework.BRWBV1zN.js";const n="/VonSim8/docs/images/cicloinstruccion3.png",M=JSON.parse('{"title":"Ciclo de la instrucción","description":"","frontmatter":{},"headers":[],"relativePath":"reference/instructioncycle.md","filePath":"reference/instructioncycle.md","lastUpdated":1757980174000}'),i={name:"reference/instructioncycle.md"};function t(a,e,s,l,g,p){return r(),c("div",null,e[0]||(e[0]=[d('<h1 id="ciclo-de-la-instruccion" tabindex="-1">Ciclo de la instrucción <a class="header-anchor" href="#ciclo-de-la-instruccion" aria-label="Permalink to &quot;Ciclo de la instrucción&quot;">​</a></h1><p>El ciclo de la instrucción es la secuencia de pasos que realiza la <strong>Unidad de Control (UC)</strong> para ejecutar cada instrucción de un programa. Este proceso es fundamental para el funcionamiento de cualquier computadora, ya que involucra elementos clave como registros, buses de datos, direcciones y señales de control generadas por la UC.</p><p>Las microoperaciones se expresan mediante la notación de transferencia entre registros:</p><div style="text-align:center;"> destino ← origen </div><div style="text-align:center;"><img src="'+n+'" alt="Flujo del ciclo de instrucción en VonSim8" style="max-width:85%;"></div><p>El ciclo se divide en dos etapas principales: <strong>captación (fetch)</strong> y <strong>ejecución</strong>.</p><hr><h2 id="etapa-1-captacion" tabindex="-1">Etapa 1: Captación <a class="header-anchor" href="#etapa-1-captacion" aria-label="Permalink to &quot;Etapa 1: Captación&quot;">​</a></h2><p>Esta etapa es igual para todas las instrucciones. Su objetivo es leer la instrucción desde la memoria y cargarla en el <strong>Registro de Instrucciones</strong> (<code>IR</code>). Consta de tres microoperaciones:</p><ol><li><strong><code>MAR</code> ← <code>IP</code></strong><br> La UC transfiere al <strong>Registro de Direcciones de Memoria</strong> (<code>MAR</code>) la dirección de la próxima instrucción, almacenada en el <strong>Puntero de Instrucción</strong> (<code>IP</code>).</li><li><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> | <strong><code>IP</code> ← <code>IP</code> + 1</strong><br> La UC activa la señal de lectura para leer la instrucción ubicada en la dirección contenida en el <code>MAR</code>. El valor leído se guarda en el <strong>Registro de Datos de Memoria</strong> (<code>MBR</code>) y, al mismo tiempo, el <code>IP</code> se incrementa para apuntar a la siguiente instrucción u operando.</li><li><strong><code>IR</code> ← <code>MBR</code></strong><br> El contenido del <code>MBR</code> se transfiere al <code>IR</code>, dejando la instrucción lista para ser decodificada y ejecutada.</li></ol><hr><h2 id="etapa-2-ejecucion" tabindex="-1">Etapa 2: Ejecución <a class="header-anchor" href="#etapa-2-ejecucion" aria-label="Permalink to &quot;Etapa 2: Ejecución&quot;">​</a></h2><p>En esta etapa, el <strong>decodificador de instrucciones</strong> interpreta el valor en el registro <code>IR</code>. A partir del código de operación, lee las microinstrucciones necesarias en la <strong>memoria de control</strong> para determinar el tipo de instrucción, la cantidad de operandos y el modo de direccionamiento.</p><p>Luego, estas microinstrucciones se envían al <strong>secuenciador</strong>, que genera las señales de control precisas para ejecutar la operación.</p><p>A continuación se detallan los ciclos para las instrucciones más comunes:</p><h3 id="instrucciones-con-dos-operandos-mov-add-sub-cmp" tabindex="-1">Instrucciones con dos operandos: <strong>MOV</strong>, <strong>ADD</strong>, <strong>SUB</strong>, <strong>CMP</strong> <a class="header-anchor" href="#instrucciones-con-dos-operandos-mov-add-sub-cmp" aria-label="Permalink to &quot;Instrucciones con dos operandos: **MOV**, **ADD**, **SUB**, **CMP**&quot;">​</a></h3><h4 id="destino-en-registro-rx" tabindex="-1">Destino en registro (<code>Rx</code>) <a class="header-anchor" href="#destino-en-registro-rx" aria-label="Permalink to &quot;Destino en registro (`Rx`)&quot;">​</a></h4><ul><li><p><strong>Modo entre registros (<code>Rx</code>, <code>Ry</code>)</strong></p><ol start="4"><li>La ejecución se realiza en un solo paso: <ul><li><strong>MOV</strong>: <code>Rx</code> ← <code>Ry</code></li><li><strong>ADD</strong>: <code>Rx</code> ← <code>Rx</code> + <code>Ry</code> | update(Flags)</li><li><strong>SUB</strong>: <code>Rx</code> ← <code>Rx</code> - <code>Ry</code> | update(Flags)</li><li><strong>CMP</strong>: <code>Rx</code> - <code>Ry</code> | update(Flags) <em>(solo actualiza flags)</em></li></ul></li></ol></li><li><p><strong>Modo directo (<code>Rx</code>, <code>[Dirección]</code>)</strong></p><ol start="4"><li><strong><code>MAR</code> ← <code>IP</code></strong> — Obtener dirección del operando fuente.</li><li><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> | <strong><code>IP</code> ← <code>IP</code> + 1</strong> — Leer la dirección desde memoria e incrementar <code>IP</code>.</li><li><strong><code>MAR</code> ← <code>MBR</code></strong> — Transferir la dirección al <code>MAR</code>.</li><li><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> — Obtener el dato.</li><li>Ejecutar la operación: <ul><li><strong>MOV</strong>: <code>Rx</code> ← <code>MBR</code></li><li><strong>ADD</strong>: <code>Rx</code> ← <code>Rx</code> + <code>MBR</code> | update(Flags)</li><li><strong>SUB</strong>: <code>Rx</code> ← <code>Rx</code> - <code>MBR</code> | update(Flags)</li><li><strong>CMP</strong>: <code>Rx</code> - <code>MBR</code> | update(Flags) <em>(solo actualiza flags)</em></li></ul></li></ol></li><li><p><strong>Modo inmediato (<code>Rx</code>, <code>Dato</code>)</strong></p><ol start="4"><li><strong><code>MAR</code> ← <code>IP</code></strong> — Obtener dirección del dato inmediato.</li><li><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> | <strong><code>IP</code> ← <code>IP</code> + 1</strong> — Leer el dato e incrementar <code>IP</code>.</li><li>Ejecutar la operación (igual que en el caso anterior).</li></ol></li><li><p><strong>Modo indirecto (<code>Rx</code>, <code>[BL]</code>)</strong></p><ol start="4"><li><strong><code>MAR</code> ← <code>BL</code></strong> — Obtener dirección del dato desde el registro <code>BL</code>.</li><li><strong><code>MBR</code> ← read(Memoria[MAR])</strong> — Leer el dato.</li><li>Ejecutar la operación (igual que en el caso anterior).</li></ol></li></ul><h4 id="destino-en-memoria-direccion-o-bl" tabindex="-1">Destino en memoria (<code>[Dirección]</code> o <code>[BL]</code>) <a class="header-anchor" href="#destino-en-memoria-direccion-o-bl" aria-label="Permalink to &quot;Destino en memoria (`[Dirección]` o `[BL]`)&quot;">​</a></h4><p>En este caso, el resultado de la operación se almacena en una dirección de memoria especificada en la instrucción o indicada por el contenido del registro <code>BL</code>.</p><ul><li><p><strong>Modo directo (<code>[Dirección]</code>, <code>Ry</code>)</strong></p><ol start="4"><li><strong><code>MAR</code> ← <code>IP</code></strong> — Obtener dirección destino.</li><li><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> | <strong><code>IP</code> ← <code>IP</code> + 1</strong> — Leer la dirección e incrementar <code>IP</code>.</li><li><strong><code>MAR</code> ← <code>MBR</code></strong> — Transferir dirección a <code>MAR</code>.</li></ol><p>Según la instrucción:</p><p><strong>MOV</strong>:</p><ol start="7"><li><p><strong><code>Ry</code> ← <code>MBR</code></strong> — Copiar <code>Ry</code> al <code>MBR</code>.</p></li><li><p><strong>write(Memoria[<code>MAR</code>]) ← <code>MBR</code></strong> — Escribir en memoria.</p></li></ol><p><strong>ADD/SUB/CMP</strong>:</p><ol start="7"><li><p><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> — Leer el dato.</p></li><li><p>Ejecutar la operación:</p><ul><li><strong>ADD</strong>: <code>MBR</code> ← <code>MBR</code> + <code>Ry</code> | update(Flags)</li><li><strong>SUB</strong>: <code>MBR</code> ← <code>MBR</code> - <code>Ry</code> | update(Flags)</li><li><strong>CMP</strong>: <code>MBR</code> - <code>Ry</code> | update(Flags) <strong>(solo actualiza flags)</strong></li></ul></li><li><p>Si es <strong>ADD</strong> o <strong>SUB</strong>: <strong>write(Memoria[<code>MAR</code>]) ← <code>MBR</code></strong> — Escribir en memoria.</p></li></ol></li><li><p><strong>Modo indirecto (<code>[BL]</code>, <code>Ry</code>)</strong></p><ol start="4"><li><strong><code>MAR</code> ← <code>BL</code></strong> — Transferir dirección de destino (en <code>BL</code>) a <code>MAR</code>.</li></ol><p>Según la instrucción:</p><p><strong>MOV</strong>:</p><ol start="5"><li><p><strong><code>MBR</code> ← <code>Ry</code></strong> — Copiar <code>Ry</code> al <code>MBR</code>.</p></li><li><p><strong>write(Memoria[MAR]) ← <code>MBR</code></strong> — Escribir en memoria.</p></li></ol><p><strong>ADD/SUB/CMP</strong>:</p><ol start="5"><li><p><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> — Leer el dato.</p></li><li><p><strong>ADD/SUB/CMP</strong>: Ejecutar la operación (igual que en el caso anterior).</p></li><li><p>Si es <strong>ADD</strong> o <strong>SUB</strong>: <strong>write(Memoria[<code>MAR</code>]) ← <code>MBR</code></strong> — Escribir en memoria.</p></li></ol></li><li><p><strong>Modo directo-inmediato (<code>[Dirección]</code>, <code>Dato</code>)</strong></p><ol start="4"><li><strong><code>MAR</code> ← <code>IP</code></strong> — Obtener dirección destino.</li><li><strong><code>MBR</code> ← read(Memoria[MAR])</strong> | <strong><code>IP</code> ← <code>IP</code> + 1</strong> — Leer dirección e incrementar <code>IP</code>.</li><li><strong><code>MAR</code> ← <code>IP</code></strong> | <strong><code>ri</code> ← <code>MBR</code></strong> — Preparar para leer el dato y guardar la dirección destino en un registro intermedio (<code>ri</code>).</li><li><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> | <strong><code>IP</code> ← <code>IP</code> + 1</strong> — Leer dato e incrementar <code>IP</code>.</li></ol><p>Según la instrucción:</p><p><strong>MOV</strong>:</p><ol start="8"><li><p><strong><code>MAR</code> ← <code>ri</code></strong> — Copiar dirección destino.</p></li><li><p><strong>write(Memoria[<code>MAR</code>]) ← <code>MBR</code></strong> — Escribir en memoria.</p></li></ol><p><strong>ADD/SUB/CMP</strong>:</p><ol start="8"><li><p><strong><code>MAR</code> ← <code>ri</code></strong> | <strong><code>id</code> ← <code>MBR</code></strong> — Cargar dirección destino y guardar el valor inmediato en <code>id</code>.</p></li><li><p><strong><code>MBR</code> ← read(Memoria[MAR])</strong> — Leer el valor actual de destino.</p></li><li><p>Ejecutar la operación:</p></li></ol><ul><li><strong>ADD</strong>: <code>MBR</code> ← <code>MBR</code> + <code>id</code> | update(Flags)</li><li><strong>SUB</strong>: <code>MBR</code> ← <code>MBR</code> - <code>id</code> | update(Flags)</li><li><strong>CMP</strong>: <code>MBR</code> - <code>id</code> | update(Flags) <em>(solo actualiza flags)</em></li></ul><ol start="11"><li>Si es <strong>ADD</strong> o <strong>SUB</strong>: <strong>write(Memoria[<code>MAR</code>]) ← <code>MBR</code></strong> — Escribir en memoria.</li></ol></li><li><p><strong>Modo indirecto-inmediato (<code>[BL]</code>, <code>Dato</code>)</strong></p><ol start="4"><li><strong><code>MAR</code> ← <code>IP</code></strong> — Obtener dirección del dato inmediato.</li><li><strong><code>MBR</code> ← read(Memoria[<code>MAR</code>])</strong> | <strong><code>IP</code> ← <code>IP</code> + 1</strong> — Leer dato e incrementar <code>IP</code>.</li></ol><p>Según la instrucción:</p><p><strong>MOV</strong>:</p><ol start="6"><li><p><strong><code>MAR</code> ← <code>BL</code></strong> — Copiar dirección de destino.</p></li><li><p><strong>write(Memoria[MAR]) ← <code>MBR</code></strong></p></li></ol><p><strong>ADD/SUB/CMP</strong>:</p><ol start="6"><li><p><strong><code>MAR</code> ← <code>BL</code></strong> | <strong><code>id</code> ← <code>MBR</code></strong> — Cargar la dirección destino y guardar el valor inmediato en id.</p></li><li><p><strong><code>MBR</code> ← read(Memoria[MAR])</strong> — Leer el valor actual de destino.</p></li><li><p>Ejecutar la operación (igual que en el caso anterior).</p></li><li><p>Si es <strong>ADD</strong> o <strong>SUB</strong>: <strong>write(Memoria[<code>MAR</code>]) ← <code>MBR</code></strong> — Escribir en memoria.</p></li></ol></li></ul><hr><h3 id="instrucciones-con-un-operando-jmp-jxx" tabindex="-1">Instrucciones con un operando: <strong>JMP</strong>, <strong>Jxx</strong> <a class="header-anchor" href="#instrucciones-con-un-operando-jmp-jxx" aria-label="Permalink to &quot;Instrucciones con un operando: **JMP**, **Jxx**&quot;">​</a></h3><ul><li><p><strong>Salto a (<code>Dirección</code>)</strong></p><ol start="4"><li><strong><code>MAR</code> ← <code>IP</code></strong> — Obtener la dirección del salto.</li><li><strong><code>MBR</code> ← read(Memoria[MAR])</strong> | <strong><code>IP</code> ← <code>IP</code> + 1</strong> — Leer la dirección de destino e incrementar <code>IP</code>.</li></ol><p>Según la instrucción:</p><p><strong>JMP</strong>:</p><ol start="6"><li><strong><code>IP</code> ← <code>MBR</code></strong></li></ol><p><strong>Jxx</strong>:</p><ol start="6"><li><strong><code>IP</code> ← <code>MBR</code></strong> si se cumple la condición del flag <code>xx</code>; en caso contrario, continúa con la siguiente instrucción.</li></ol></li></ul><hr><h3 id="instrucciones-sin-operandos" tabindex="-1">Instrucciones sin operandos <a class="header-anchor" href="#instrucciones-sin-operandos" aria-label="Permalink to &quot;Instrucciones sin operandos&quot;">​</a></h3><ul><li><p><strong>HLT</strong></p><ol start="4"><li>Detiene la ejecución de la CPU.</li></ol></li></ul>',27)]))}const R=o(i,[["render",t]]);export{M as __pageData,R as default};
