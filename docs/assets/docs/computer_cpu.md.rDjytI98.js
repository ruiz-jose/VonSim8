import{_ as a,c as i,o as s,ag as o}from"./chunks/framework.BRWBV1zN.js";const m=JSON.parse('{"title":"CPU","description":"","frontmatter":{},"headers":[],"relativePath":"computer/cpu.md","filePath":"computer/cpu.md","lastUpdated":1760043327000}'),r={name:"computer/cpu.md"};function t(n,e,l,c,d,p){return s(),i("div",null,e[0]||(e[0]=[o(`<h1 id="cpu" tabindex="-1">CPU <a class="header-anchor" href="#cpu" aria-label="Permalink to &quot;CPU&quot;">​</a></h1><p>El procesador que utiliza este entorno de simulación está basado en el <strong>Intel 8088</strong>.</p><blockquote><p><strong>Referencia:</strong> Consulta la <a href="https://www.ceibo.com/eng/datasheets/Intel-8088-Data-Sheet.pdf" target="_blank" rel="noreferrer">hoja de especificaciones del Intel 8088</a> para más detalles sobre la arquitectura original.</p></blockquote><p>:::warning[Simplificaciones] VonSim8 no busca ser un emulador fiel del 8088, sino una herramienta educativa. Por eso, se han hecho varias simplificaciones respecto al procesador real: el set de instrucciones es más pequeño, la memoria es limitada y la codificación es más simple. :::</p><h2 id="puertos" tabindex="-1">Puertos <a class="header-anchor" href="#puertos" aria-label="Permalink to &quot;Puertos&quot;">​</a></h2><p>El procesador cuenta con los siguientes puertos:</p><ul><li>8 bits de direcciones de memoria (bus de direcciones, con su respectivo <em>buffer</em> <code>MAR</code>)</li><li>8 bits de datos (bus de datos, con su respectivo <em>buffer</em> <code>MBR</code>)</li><li>1 bit para la señal de lectura (<code>RD</code>)</li><li>1 bit para la señal de escritura (<code>WR</code>)</li><li>1 bit para indicar si la escritura es a <a href="./memory.html">memoria principal</a> o a un módulo de <a href="./../io/modules/index.html">entrada/salida</a> (<code>IO/M</code>, siendo <code>1</code> para E/S)</li><li>1 bit para la petición de interrupción (<code>INTR</code>)</li><li>1 bit para la señal de <em>acknowledge</em> de interrupción (<code>INTA</code>)</li></ul><h2 id="registros" tabindex="-1">Registros <a class="header-anchor" href="#registros" aria-label="Permalink to &quot;Registros&quot;">​</a></h2><ul><li>Cuatro registros multipropósito de 8 bits (<code>AL</code>, <code>BL</code>, <code>CL</code>, <code>DL</code>).</li><li>Registro de pila (<code>SP</code>) y registros internos (<code>FLAGS</code>, <code>IP</code>, <code>IR</code>, <code>MAR</code>, <code>MBR</code>, <code>id</code>, <code>ri</code>).</li></ul><p>Los registros de proposito general pueden ser accedidos y modificados por el programador. Los internos son gestionados por la CPU.</p><p>El procesador cuenta con cuatro registros de propósito general de 8 bits: <code>AL</code>, <code>BL</code>, <code>CL</code> y <code>DL</code>. Además, para el funcionamiento de la <a href="#pila">pila</a>, cuenta con un registro <code>SP</code> (<em>stack pointer</em>) de 8 bits. Estos registros pueden ser accedidos por el usuario.</p><p>Dentro de los registros internos que no pueden ser accedidos por el usuario, se encuentra el registro <a href="#flags"><code>FLAGS</code></a> (<em>flags register</em>, 8 bits), el <code>IP</code> (<em>instruction pointer</em>, 8 bits) que almacena la dirección de la próxima instrucción a ejecutar, el <code>IR</code> (<em>instruction register</em>, 8 bits) que almacena el byte de la instrucción que se está analizando/decodificando en un instante dado, y el <code>MAR</code> (<em>memory address register</em>, 8 bits) que almacena la dirección de memoria que se quiere propagar por el bus de direcciones, y el <code>MBR</code> (<em>memory buffer register</em>, 8 bits) que almacena el byte que se quiere propagar o se ha recibido por el bus de datos.</p><p>Hay además algunos registros internos que sirven de intermediarios para realizar ejecutar instrucciones, como pueden ser el <code>ri</code> para almacenar una dirección temporal, el <code>id</code> para almacenar un dato temporal.</p><h2 id="unidad-de-control" tabindex="-1">Unidad de Control <a class="header-anchor" href="#unidad-de-control" aria-label="Permalink to &quot;Unidad de Control&quot;">​</a></h2><p>La unidad de control es responsable de coordinar todas las operaciones de la CPU. Se encarga de:</p><ul><li><strong>Decodificación de instrucciones</strong>: Interpreta el código de operación de cada instrucción</li><li><strong>Generación de señales de control</strong>: Activa las señales necesarias para ejecutar microoperaciones</li><li><strong>Secuenciación</strong>: Controla el orden de ejecución de las operaciones</li></ul><h3 id="memoria-de-control" tabindex="-1">Memoria de Control <a class="header-anchor" href="#memoria-de-control" aria-label="Permalink to &quot;Memoria de Control&quot;">​</a></h3><p>Para una comprensión más profunda de cómo funciona la unidad de control, puedes visualizar la <a href="./control-memory.html">memoria de control</a> que muestra las microinstrucciones y microoperaciones de cada instrucción.</p><h3 id="secuenciador" tabindex="-1">Secuenciador <a class="header-anchor" href="#secuenciador" aria-label="Permalink to &quot;Secuenciador&quot;">​</a></h3><p>El <a href="./sequencer.html">secuenciador</a> complementa la memoria de control mostrando cómo se controla la secuencia de microoperaciones y las señales de control generadas en cada fase del ciclo de instrucción.</p><h2 id="alu" tabindex="-1">ALU <a class="header-anchor" href="#alu" aria-label="Permalink to &quot;ALU&quot;">​</a></h2><p>La ALU (<em>Arithmetic Logic Unit</em>) permite realizar operaciones aritméticas y lógicas de 8 bits. Las operaciones disponibles son: <a href="./instructions/add.html"><code>ADD</code></a>, <a href="./instructions/adc.html"><code>ADC</code></a>, <a href="./instructions/inc.html"><code>INC</code></a>, <a href="./instructions/sub.html"><code>SUB</code></a>, <a href="./instructions/sbb.html"><code>SBB</code></a>, <a href="./instructions/dec.html"><code>DEC</code></a>, <a href="./instructions/neg.html"><code>NEG</code></a>, <a href="./instructions/not.html"><code>NOT</code></a>, <a href="./instructions/and.html"><code>AND</code></a> y <a href="./instructions/or.html"><code>OR</code></a>. Todas estas operaciones modifican el registro <code>FLAGS</code>.</p><h3 id="flags" tabindex="-1">Flags <a class="header-anchor" href="#flags" aria-label="Permalink to &quot;Flags&quot;">​</a></h3><p>El registro <code>FLAGS</code> es un registro de 8 bits que contiene las <em>flags</em> mostradas en la siguiente tabla. Este registro no es directamente accesible por el usuario, pero puede ser modificado por las operaciones de la ALU y pueden realizarse saltos condicionales en base a sus valores.</p><table tabindex="0"><thead><tr><th style="text-align:center;">Bit #</th><th style="text-align:center;">Abreviatura</th><th style="text-align:left;">Descripción</th></tr></thead><tbody><tr><td style="text-align:center;">0</td><td style="text-align:center;"><code>Z</code></td><td style="text-align:left;"><em>Flag</em> de cero</td></tr><tr><td style="text-align:center;">1</td><td style="text-align:center;"><code>C</code></td><td style="text-align:left;"><em>Flag</em> de acarreo</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><code>O</code></td><td style="text-align:left;"><em>Flag</em> de overflow</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><code>S</code></td><td style="text-align:left;"><em>Flag</em> de signo</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><code>I</code></td><td style="text-align:left;"><em>Flag</em> de interrupción</td></tr></tbody></table><p>El resto de bits están reservados / no se utilizan.</p><h2 id="pila" tabindex="-1">Pila <a class="header-anchor" href="#pila" aria-label="Permalink to &quot;Pila&quot;">​</a></h2><p>El procesador implementa la pila como método de almacenamiento accesible por el usuario y por la misma CPU para su correcto funcionamiento. Esta es del estilo <em>Last In, First Out</em> (LIFO), es decir, el último elemento en entrar es el primero en salir. La pila se encuentra en la memoria principal, comenzando en la dirección más alta de la misma (<code>FFh</code>) y creciendo hacia las direcciones más bajas (<code>FEh</code>, <code>FCh</code>, etc.). El tope de la pila se guarda en el registro <code>SP</code>. Todos los elementos de la pila son de 8 bits.</p><h2 id="subrutinas" tabindex="-1">Subrutinas <a class="header-anchor" href="#subrutinas" aria-label="Permalink to &quot;Subrutinas&quot;">​</a></h2><p>El procesador también implementa subrutinas. Estas son pequeños fragmentos de código que pueden ser llamados desde cualquier parte del programa. Para ello, se utiliza la instrucción <a href="./instructions/call.html"><code>CALL</code></a>. Esta instrucción almacena el <code>IP</code> en la <a href="#pila">pila</a>, y luego realiza un salto a la dirección de la subrutina, modificando el <code>IP</code> para que este apunte a la primera instrucción de la subrutina. Para volver de la subrutina, se utiliza la instrucción <a href="./instructions/ret.html"><code>RET</code></a>, que desapila la dirección apilada previamente por <code>CALL</code> y restaura el <code>IP</code>, volviendo a el punto de ejecución posterior a la llamada a la subrutina.</p><p>Ejemplo de subrutina:</p><div class="language-vonsim vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vonsim</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> al</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum3</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      ; ax = 6</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      hlt</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      ; suma al, bl y cl</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      sum3: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> al</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bl</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> al</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cl</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            ret</span></span></code></pre></div><h2 id="interrupciones" tabindex="-1">Interrupciones <a class="header-anchor" href="#interrupciones" aria-label="Permalink to &quot;Interrupciones&quot;">​</a></h2><p>El procesador admite interrupciones por hardware y por software, que pueden ser emitidas por el <a href="./../io/modules/pic.html">PIC</a> o por la instrucción <a href="./instructions/int.html"><code>INT</code></a> respectivamente. Para ejecutar interrupciones por hardware, el procesador debe estar habilitado para recibir interrupciones. Esto es, <code>IF=1</code> (la <em>flag</em> de interrupciones activada).</p><p>Ambas interrupciones deben propocionar un número de interrupción. En el caso de las interrupciones por software, esta es dada por el operando de la instrucción <code>INT</code> (<a href="./instructions/int.html">ver más</a>). En el caso de las interrupciones por hardware, esta es dada por el PIC (<a href="./../io/modules/pic.html#funcionamiento">ver cómo se obtiene</a>). El número de interrupción debe ser un número entre <code>0</code> y <code>7</code>.</p><p>Una vez interrumpido, el procesador ejecutará la rutina de interrupción asociada a ese número de interrupción. La dirección de comienzo de esta rutina estará almacenada en el vector de interrupciones. Este vector ocupa las celdas <code>00h</code> hasta <code>07h</code> de la memoria principal, y cada elemento del vector tiene 1 byte de largo -- el primer elemento se encuentra en <code>0h</code>, el segundo en <code>1h</code>, el tercero en <code>2h</code>, y así. Cada elemento corresponde con la dirección de inicio de la rutina de interrupción.</p><p>Específicamente, el procesador:</p><ol><li>obtiene el número de la interrupción (0-7),</li><li>apila el registro <a href="#flags"><code>FLAGS</code></a>,</li><li>inhabilita las interrupciones (<code>IF=0</code>),</li><li>apila el registro <code>IP</code>,</li><li>obtiene la dirección de la rutina de interrupción del vector de interrupciones,</li><li>modifica el <code>IP</code> para que apunte a la dirección de la rutina de interrupción.</li></ol><p>Y así se comienza a ejecutar la rutina de interrupción. Estas tienen el mismo formato que una <a href="#subrutinas">subrutina</a> salvo que terminan en <a href="./instructions/iret.html"><code>IRET</code></a> en vez de <a href="./instructions/ret.html"><code>RET</code></a>.</p><h3 id="llamadas-al-sistema" tabindex="-1">Llamadas al sistema <a class="header-anchor" href="#llamadas-al-sistema" aria-label="Permalink to &quot;Llamadas al sistema&quot;">​</a></h3><p>El simulador permite realizar llamadas al sistema o <em>syscalls</em>. En el simulador, estas llamadas son realizadas idénticamente a las interrupciones. Así, para realizar una <em>syscall</em> basta con interrumpir a la CPU con el número de interrupción correspondiente. Estos números son:</p><ul><li><code>INT 0</code>: termina la ejecución del programa, equivalente a la instrucción <a href="./instructions/hlt.html"><code>HLT</code></a>;</li><li><code>INT 6</code>: lee un carácter del <a href="./../io/devices/keyboard.html">teclado</a>;</li><li><code>INT 7</code>: escribe una cadena de caracteres en <a href="./../io/devices/screen.html">pantalla</a>.</li></ul><p>Las direcciones del vector de interrupciones asociadas a estos números están protegidas por el sistema, impidiendo que el usuario las modifique.</p><p>El contenido de estas rutinas se encuentran almacenadas en el <a href="./memory.html">monitor del sistema</a> en las direcciones <code>A0h</code>, <code>B0h</code> y <code>C0h</code> respectivamente.</p>`,44)]))}const h=a(r,[["render",t]]);export{m as __pageData,h as default};
