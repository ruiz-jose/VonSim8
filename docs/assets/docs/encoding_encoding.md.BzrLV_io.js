import{_ as e,c as d,o,ag as c}from"./chunks/framework.BRWBV1zN.js";const D=JSON.parse('{"title":"Codificación","description":"","frontmatter":{},"headers":[],"relativePath":"encoding/encoding.md","filePath":"encoding/encoding.md","lastUpdated":1758462394000}'),i={name:"encoding/encoding.md"};function a(n,t,r,l,s,M){return o(),d("div",null,t[0]||(t[0]=[c('<h1 id="codificacion" tabindex="-1">Codificación <a class="header-anchor" href="#codificacion" aria-label="Permalink to &quot;Codificación&quot;">​</a></h1><p>Aquí se denota la codificación en binario de cada una de las instrucciones del simulador. Pese a que el set de instrucciones esté basado en el del Intel 8088, la codificación se ha simplificado con fines prácticos y didácticos.</p><table tabindex="0"><thead><tr><th style="text-align:center;">Categoría</th><th style="text-align:center;">Instrucción</th><th style="text-align:center;">Código operación</th><th style="text-align:center;">Operandos</th><th style="text-align:left;">Acción</th></tr></thead><tbody><tr><td style="text-align:center;">Transferencia de datos</td><td style="text-align:center;">MOV</td><td style="text-align:center;">0, 1, 2</td><td style="text-align:center;">2</td><td style="text-align:left;">Copiar entre registros, cargar de memoria a registro, almacenar en memoria</td></tr><tr><td style="text-align:center;">Procesamiento de datos</td><td style="text-align:center;">ADD</td><td style="text-align:center;">3, 4, 5</td><td style="text-align:center;">2</td><td style="text-align:left;">Operación aritmética: operando1 = operando1 + operando2</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">SUB</td><td style="text-align:center;">6, 7, 8</td><td style="text-align:center;">2</td><td style="text-align:left;">Operación aritmética: operando1 = operando1 - operando2</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">CMP</td><td style="text-align:center;">9, 10, 11</td><td style="text-align:center;">2</td><td style="text-align:left;">Comparación: operando1 - operando2 (no actualiza el destino)</td></tr><tr><td style="text-align:center;">Control de flujo</td><td style="text-align:center;">JMP / Jxx</td><td style="text-align:center;">12</td><td style="text-align:center;">1</td><td style="text-align:left;">Salto incondicional JMP, condicionales Jxx</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">HLT</td><td style="text-align:center;">13</td><td style="text-align:center;">0</td><td style="text-align:left;">HLT: detiene el CPU</td></tr></tbody></table><h2 id="acronimos-y-abreviaciones" tabindex="-1">Acrónimos y abreviaciones <a class="header-anchor" href="#acronimos-y-abreviaciones" aria-label="Permalink to &quot;Acrónimos y abreviaciones&quot;">​</a></h2><p>A lo largo de la codificación se usan las siguientes abreviaturas:</p><ul><li><p><code>Rx</code> o <code>Ry</code>: referencian registros.</p><table tabindex="0"><thead><tr><th style="text-align:center;"><code>Código</code></th><th style="text-align:center;"><code>Nombre</code></th></tr></thead><tbody><tr><td style="text-align:center;"><code>00</code></td><td style="text-align:center;"><code>AL</code></td></tr><tr><td style="text-align:center;"><code>01</code></td><td style="text-align:center;"><code>CL</code></td></tr><tr><td style="text-align:center;"><code>10</code></td><td style="text-align:center;"><code>DL</code></td></tr><tr><td style="text-align:center;"><code>11</code></td><td style="text-align:center;"><code>BL</code></td></tr></tbody></table></li></ul><p>La codificación de instrucciones en VonSim8 está simplificada para fines didácticos, permitiendo a los estudiantes centrarse en los conceptos fundamentales sin la complejidad técnica de arquitecturas reales.</p><p>Para las instrucciones con un registro como operando, <code>Ry</code> codifica el registro fuente y <code>Rx</code> el registro destino.</p><h2 id="instrucciones-con-dos-operandos-binarias" tabindex="-1">Instrucciones con dos operandos (Binarias) <a class="header-anchor" href="#instrucciones-con-dos-operandos-binarias" aria-label="Permalink to &quot;Instrucciones con dos operandos (Binarias)&quot;">​</a></h2><p>Instrucciones con dos operandos <code>MOV</code>, <code>ADD</code>, <code>SUB</code> y <code>CMP</code> están codificadas con 1, 2 o 3 bytes. Los primeros 4 bits de la identifican el <code>opcode</code> de la instrucción y los 4 bits restantes identifican el modo de direccionamiento. Estas instrucciones reciben dos operandos y soportan varios modos de direccionamiento. Esta información está codificada en el primer byte junto al código de operación de la instrucción según la siguiente tabla:</p><table tabindex="0"><thead><tr><th style="text-align:left;">Destino</th><th style="text-align:left;">Fuente</th><th style="text-align:center;">Primer Byte</th><th style="text-align:left;">Segundo Byte</th><th style="text-align:left;">Tercer Byte</th></tr></thead><tbody><tr><td style="text-align:left;">Registro</td><td style="text-align:left;">Registro</td><td style="text-align:center;"><code>----RxRy</code></td><td style="text-align:left;">—</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Registro</td><td style="text-align:left;">Memoria (directo)</td><td style="text-align:center;"><code>----Rx00</code></td><td style="text-align:left;">dir</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Registro</td><td style="text-align:left;">Memoria (indirecto)</td><td style="text-align:center;"><code>----Rx01</code></td><td style="text-align:left;">—</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Registro</td><td style="text-align:left;">Inmediato</td><td style="text-align:center;"><code>----Rx10</code></td><td style="text-align:left;">dato</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Memoria (directo)</td><td style="text-align:left;">Registro</td><td style="text-align:center;"><code>----00Ry</code></td><td style="text-align:left;">dir</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Memoria (indirecto)</td><td style="text-align:left;">Registro</td><td style="text-align:center;"><code>----01Ry</code></td><td style="text-align:left;">—</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Memoria (directo)</td><td style="text-align:left;">Inmediato</td><td style="text-align:center;"><code>----1100</code></td><td style="text-align:left;">dir</td><td style="text-align:left;">dato</td></tr><tr><td style="text-align:left;">Memoria (indirecto)</td><td style="text-align:left;">Inmediato</td><td style="text-align:center;"><code>----1101</code></td><td style="text-align:left;">dato</td><td style="text-align:left;"></td></tr></tbody></table><p>A continuacion se muestran las combinaciones posibles para cada instrucción de dos operandos:</p><table tabindex="0"><thead><tr><th>#</th><th>Instrucción</th><th>Acción</th><th>Codificación</th></tr></thead><tbody><tr><td>0</td><td><code>MOV Rx, Ry</code></td><td><code>Rx</code> ← <code>Ry</code></td><td><code>0000 RxRy</code></td></tr><tr><td>1</td><td><code>MOV Rx, [M]</code></td><td><code>Rx</code> ← <code>Mem[Dirección]</code></td><td><code>0001 Rx00 MMMMMMMM</code></td></tr><tr><td>1</td><td><code>MOV Rx, [BL]</code></td><td><code>Rx</code> ← <code>Mem[BL]</code></td><td><code>0001 Rx01</code></td></tr><tr><td>1</td><td><code>MOV Rx, D</code></td><td><code>Rx</code> ← <code>Dato</code></td><td><code>0001 Rx10 MMMMMMMM</code></td></tr><tr><td>2</td><td><code>MOV [M], Ry</code></td><td><code>Mem[Dirección]</code> ← <code>Rx</code></td><td><code>0010 00Ry MMMMMMMM</code></td></tr><tr><td>2</td><td><code>MOV [BL], Ry</code></td><td><code>Mem[BL]</code> ← <code>Rx</code></td><td><code>0010 01Ry</code></td></tr><tr><td>2</td><td><code>MOV [M], D</code></td><td><code>Mem[Dirección]</code> ← <code>Dato</code></td><td><code>0010 1100 MMMMMMMM DDDDDDDD</code></td></tr><tr><td>2</td><td><code>MOV [BL], D</code></td><td><code>Mem[BL]</code> ← <code>Dato</code></td><td><code>0010 1101 DDDDDDDD</code></td></tr><tr><td>3</td><td><code>ADD Rx, Ry</code></td><td><code>Rx</code> ← <code>Rx + Ry</code></td><td><code>0011 RxRy</code></td></tr><tr><td>4</td><td><code>ADD Rx, [M]</code></td><td><code>Rx</code> ← <code>Rx + Mem[Dirección]</code></td><td><code>0100 Rx00 MMMMMMMM</code></td></tr><tr><td>4</td><td><code>ADD Rx, [BL]</code></td><td><code>Rx</code> ← <code>Rx + Mem[BL]</code></td><td><code>0100 Rx01</code></td></tr><tr><td>4</td><td><code>ADD Rx, D</code></td><td><code>Rx</code> ← <code>Rx + Dato</code></td><td><code>0100 Rx10 DDDDDDDD</code></td></tr><tr><td>5</td><td><code>ADD [M], Ry</code></td><td><code>Mem[Dirección]</code> ← <code>Mem[Dirección] + Rx</code></td><td><code>0101 00Ry MMMMMMMM</code></td></tr><tr><td>5</td><td><code>ADD [BL], Ry</code></td><td><code>Mem[BL]</code> ← <code>Mem[BL] + Rx</code></td><td><code>0101 01Ry</code></td></tr><tr><td>5</td><td><code>ADD [M], D</code></td><td><code>Mem[Dirección]</code> ← <code>Mem[Dirección] + Dato</code></td><td><code>0101 1100 MMMMMMMM DDDDDDDD</code></td></tr><tr><td>5</td><td><code>ADD [BL], D</code></td><td><code>Mem[BL]</code> ← <code>Mem[BL] + Dato</code></td><td><code>0101 1101 DDDDDDDD</code></td></tr><tr><td>6</td><td><code>SUB Rx, Ry</code></td><td><code>Rx</code> ← <code>Rx - Ry</code></td><td><code>0110 RxRy</code></td></tr><tr><td>7</td><td><code>SUB Rx, [M]</code></td><td><code>Rx</code> ← <code>Rx - Mem[Dirección]</code></td><td><code>0111 Rx00 MMMMMMMM</code></td></tr><tr><td>7</td><td><code>SUB Rx, [BL]</code></td><td><code>Rx</code> ← <code>Rx - Mem[BL]</code></td><td><code>0111 Rx01</code></td></tr><tr><td>7</td><td><code>SUB Rx, D</code></td><td><code>Rx</code> ← <code>Rx - Dato</code></td><td><code>0111 Rx10 DDDDDDDD</code></td></tr><tr><td>8</td><td><code>SUB [M], Ry</code></td><td><code>Mem[Dirección]</code> ← <code>Mem[Dirección] - Rx</code></td><td><code>1000 00Ry MMMMMMMM</code></td></tr><tr><td>8</td><td><code>SUB [BL], Ry</code></td><td><code>Mem[BL]</code> ← <code>Mem[BL] - Rx</code></td><td><code>1000 01Ry</code></td></tr><tr><td>8</td><td><code>SUB [M], D</code></td><td><code>Mem[Dirección]</code> ← <code>Mem[Dirección] - Dato</code></td><td><code>1000 1100 MMMMMMMM DDDDDDDD</code></td></tr><tr><td>8</td><td><code>SUB [BL], D</code></td><td><code>Mem[BL]</code> ← <code>Mem[BL] - Dato</code></td><td><code>1000 1101 DDDDDDDD</code></td></tr><tr><td>9</td><td><code>CMP Rx, Ry</code></td><td><code>Rx - Ry</code></td><td><code>1001 RxRy</code></td></tr><tr><td>10</td><td><code>CMP Rx, [M]</code></td><td><code>Rx - Mem[Dirección]</code></td><td><code>1010 Rx00 MMMMMMMM</code></td></tr><tr><td>10</td><td><code>CMP Rx, [BL]</code></td><td><code>Rx - Mem[BL]</code></td><td><code>1010 Rx01</code></td></tr><tr><td>10</td><td><code>CMP Rx, D</code></td><td><code>Rx - Dato</code></td><td><code>1010 Rx10 DDDDDDDD</code></td></tr><tr><td>11</td><td><code>CMP [M], Ry</code></td><td><code>Mem[Dirección] - Rx</code></td><td><code>1011 00Ry MMMMMMMM</code></td></tr><tr><td>11</td><td><code>CMP [BL], Ry</code></td><td><code>Mem[BL] - Rx</code></td><td><code>1011 01Ry</code></td></tr><tr><td>11</td><td><code>CMP [M], D</code></td><td><code>Mem[Dirección] - Dato</code></td><td><code>1011 1100 MMMMMMMM DDDDDDDD</code></td></tr><tr><td>11</td><td><code>CMP [BL], D</code></td><td><code>Mem[BL] - Dato</code></td><td><code>1011 1101 DDDDDDDD</code></td></tr></tbody></table><h2 id="instrucciones-de-un-solo-operando-unarias" tabindex="-1">Instrucciones de un solo operando (unarias) <a class="header-anchor" href="#instrucciones-de-un-solo-operando-unarias" aria-label="Permalink to &quot;Instrucciones de un solo operando (unarias)&quot;">​</a></h2><table tabindex="0"><thead><tr><th>#</th><th>Instrucción</th><th>Acción</th><th>Codificación</th></tr></thead><tbody><tr><td>12</td><td><code>JMP M</code></td><td>Salto incondicional: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 0000 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>JZ M</code></td><td>Salta si Z=1: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 0001 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>JC M</code></td><td>Salta si C=1: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 0010 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>JS M</code></td><td>Salta si S=1: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 0011 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>JO M</code></td><td>Salta si O=1: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 0100 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>JNC M</code></td><td>Salta si C=0: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 0101 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>JNZ M</code></td><td>Salta si Z=0: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 0110 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>JNS M</code></td><td>Salta si S=0: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 0111 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>JNO M</code></td><td>Salta si O=0: <code>IP</code> ← <code>Dirección</code></td><td><code>1100 1000 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>CALL M</code></td><td>Llama a subrutina: apila IP y salta a <code>Dirección</code></td><td><code>1100 1001 MMMMMMMM</code></td></tr><tr><td>12</td><td><code>INT M</code></td><td>Ejecuta interrupción: salta a rutina en <code>Dirección</code></td><td><code>1100 1010 MMMMMMMM</code></td></tr></tbody></table><h2 id="instrucciones-sin-operandos" tabindex="-1">Instrucciones sin operandos <a class="header-anchor" href="#instrucciones-sin-operandos" aria-label="Permalink to &quot;Instrucciones sin operandos&quot;">​</a></h2><table tabindex="0"><thead><tr><th>#</th><th>Instrucción</th><th>Acción</th><th>Codificación</th></tr></thead><tbody><tr><td>13</td><td><code>HLT</code></td><td>Detiene la CPU (Halt)</td><td><code>1101 0000</code></td></tr><tr><td>13</td><td><code>RET</code></td><td>Retorna de subrutina: recupera dirección de retorno a <code>IP</code></td><td><code>1101 0001</code></td></tr><tr><td>13</td><td><code>IRET</code></td><td>Retorna de interrupción: recupera dirección de retorno a <code>IP</code></td><td><code>1101 0010</code></td></tr><tr><td>13</td><td><code>CLI</code></td><td>Inhabilita interrupciones (Clear Interrupt Flag)</td><td><code>1101 0011</code></td></tr><tr><td>13</td><td><code>STI</code></td><td>Habilita interrupciones (Set Interrupt Flag)</td><td><code>1101 0100</code></td></tr></tbody></table><h2 id="instrucciones-de-e-s-y-pila" tabindex="-1">Instrucciones de E/S y pila <a class="header-anchor" href="#instrucciones-de-e-s-y-pila" aria-label="Permalink to &quot;Instrucciones de E/S y pila&quot;">​</a></h2><table tabindex="0"><thead><tr><th>#</th><th>Instrucción</th><th>Acción</th><th>Codificación</th></tr></thead><tbody><tr><td>14</td><td><code>OUT DL, AL</code></td><td>Envía el valor de <code>AL</code> al puerto especificado en <code>DL</code></td><td><code>1110 0000</code></td></tr><tr><td>14</td><td><code>OUT D, AL</code></td><td>Envía el valor de <code>AL</code> al puerto de dirección inmediata <code>D</code></td><td><code>1110 0001 DDDDDDDD</code></td></tr><tr><td>14</td><td><code>IN AL, DL</code></td><td>Recibe un valor desde el puerto especificado en <code>DL</code> y lo carga en <code>AL</code></td><td><code>1110 0010</code></td></tr><tr><td>14</td><td><code>IN AL, D</code></td><td>Recibe un valor desde el puerto de dirección inmediata <code>D</code> y lo carga en <code>AL</code></td><td><code>1110 0011 DDDDDDDD</code></td></tr><tr><td>14</td><td><code>PUSH Ry</code></td><td>Pone el valor de <code>Ry</code> en la pila</td><td><code>1110 01Ry</code></td></tr><tr><td>14</td><td><code>POP Rx</code></td><td>Retira el valor del tope de la pila y lo carga en <code>Rx</code></td><td><code>1110 10Rx</code></td></tr></tbody></table><h2 id="instrucciones-logicas-y-aritmeticas-de-un-operando" tabindex="-1">Instrucciones lógicas y aritméticas de un operando <a class="header-anchor" href="#instrucciones-logicas-y-aritmeticas-de-un-operando" aria-label="Permalink to &quot;Instrucciones lógicas y aritméticas de un operando&quot;">​</a></h2><table tabindex="0"><thead><tr><th>#</th><th>Instrucción</th><th>Acción</th><th>Codificación</th></tr></thead><tbody><tr><td>15</td><td><code>AND Rx, Ry</code></td><td><code>Rx</code> ← <code>Rx AND Ry</code></td><td><code>1111 RxRy</code></td></tr><tr><td>15</td><td><code>OR Rx, Ry</code></td><td><code>Rx</code> ← <code>Rx OR Ry</code></td><td><code>1111 RxRy</code></td></tr><tr><td>15</td><td><code>XOR Rx, Ry</code></td><td><code>Rx</code> ← <code>Rx XOR Ry</code></td><td><code>1111 RxRy</code></td></tr><tr><td>15</td><td><code>INC Rx</code></td><td><code>Rx</code> ← <code>Rx + 1</code></td><td><code>1111 Rx00</code></td></tr><tr><td>15</td><td><code>DEC Rx</code></td><td><code>Rx</code> ← <code>Rx - 1</code></td><td><code>1111 Rx01</code></td></tr><tr><td>15</td><td><code>NEG Rx</code></td><td><code>Rx</code> ← <code>-Rx</code> (complemento a dos)</td><td><code>1111 Rx10</code></td></tr><tr><td>15</td><td><code>NOT Rx</code></td><td><code>Rx</code> ← <code>NOT Rx</code> (complemento a uno)</td><td><code>1111 Rx11</code></td></tr></tbody></table><h2 id="instrucciones-sin-codigo-unico-de-operacion" tabindex="-1">Instrucciones sin código único de operación <a class="header-anchor" href="#instrucciones-sin-codigo-unico-de-operacion" aria-label="Permalink to &quot;Instrucciones sin código único de operación&quot;">​</a></h2><p>El simulador utiliza un código de operación de 4 bits para las instrucciones, lo que simplifica la arquitectura del sistema pero limita el número máximo de instrucciones implementables a 16 opciones diferentes. Con el objetivo de ampliar el repertorio de instrucciones sin incrementar el tamaño de la codificación, se adoptó una estrategia de agrupación para el código de operación 15.</p><p>Bajo esta implementación, las instrucciones lógicas (AND, OR y XOR) comparten el código de operación 15 con las instrucciones aritméticas de un operando (INC, DEC, NEG y NOT). Esta decisión de diseño permite mantener la compatibilidad con los modos de direccionamiento establecidos para las instrucciones aritméticas de dos operandos (ADD, SUB y CMP), garantizando consistencia en la interfaz del simulador mientras se maximiza la funcionalidad dentro de las limitaciones impuestas por el esquema de codificación de 4 bits.</p><p>Esta solución representa un compromiso eficaz entre la simplicidad arquitectural y la capacidad funcional del simulador, permitiendo una mayor diversidad de operaciones sin comprometer la claridad pedagógica del diseño. | 13 | <code>IRET</code> | Retorna de interrupción: recupera dirección de retorno a <code>IP</code> | <code>1101 0010</code> | | 13 | <code>CLI</code> | Inhabilita interrupciones (Clear Interrupt Flag) | <code>1101 0011</code> | | 13 | <code>STI</code> | Habilita interrupciones (Set Interrupt Flag) | <code>1101 0100</code> |</p><h2 id="instrucciones-de-e-s-y-pila-1" tabindex="-1">Instrucciones de E/S y pila <a class="header-anchor" href="#instrucciones-de-e-s-y-pila-1" aria-label="Permalink to &quot;Instrucciones de E/S y pila&quot;">​</a></h2><table tabindex="0"><thead><tr><th>#</th><th>Instrucción</th><th>Acción</th><th>Codificación</th></tr></thead><tbody><tr><td>14</td><td><code>OUT DL, AL</code></td><td>Envía el valor de <code>AL</code> al puerto especificado en <code>DL</code></td><td><code>1110 0000</code></td></tr><tr><td>14</td><td><code>OUT D, AL</code></td><td>Envía el valor de <code>AL</code> al puerto de dirección inmediata <code>D</code></td><td><code>1110 0001 DDDDDDDD</code></td></tr><tr><td>14</td><td><code>IN AL, DL</code></td><td>Recibe un valor desde el puerto especificado en <code>DL</code> y lo carga en <code>AL</code></td><td><code>1110 0010</code></td></tr><tr><td>14</td><td><code>IN AL, D</code></td><td>Recibe un valor desde el puerto de dirección inmediata <code>D</code> y lo carga en <code>AL</code></td><td><code>1110 0011 DDDDDDDD</code></td></tr><tr><td>14</td><td><code>PUSH Ry</code></td><td>Pone el valor de <code>Ry</code> en la pila</td><td><code>1110 01Ry</code></td></tr><tr><td>14</td><td><code>POP Rx</code></td><td>Retira el valor del tope de la pila y lo carga en <code>Rx</code></td><td><code>1110 10Rx</code></td></tr></tbody></table><h2 id="instrucciones-sin-codigo-unico-de-operacion-1" tabindex="-1">Instrucciones sin codigo único de operación <a class="header-anchor" href="#instrucciones-sin-codigo-unico-de-operacion-1" aria-label="Permalink to &quot;Instrucciones sin codigo único de operación&quot;">​</a></h2><p>El simulador utiliza un código de operación de 4 bits para las instrucciones, lo que simplifica la arquitectura del sistema pero limita el número máximo de instrucciones implementables a 16 opciones diferentes. Con el objetivo de ampliar el repertorio de instrucciones sin incrementar el tamaño de la codificación, se adoptó una estrategia de agrupación para el código de operación 15.</p><p>Bajo esta implementación, las instrucciones lógicas (AND, OR y XOR) comparten el código de operación 15 con las instrucciones aritméticas de un operando (INC, DEC, NEG y NOT). Esta decisión de diseño permite mantener la compatibilidad con los modos de direccionamiento establecidos para las instrucciones aritméticas de dos operandos (ADD, SUB y CMP), garantizando consistencia en la interfaz del simulador mientras se maximiza la funcionalidad dentro de las limitaciones impuestas por el esquema de codificación de 4 bits.</p><p>Esta solución representa un compromiso eficaz entre la simplicidad arquitectural y la capacidad funcional del simulador, permitiendo una mayor diversidad de operaciones sin comprometer la claridad pedagógica del diseño.</p>',31)]))}const y=e(i,[["render",a]]);export{D as __pageData,y as default};
