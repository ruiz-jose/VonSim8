import{_ as e,c as i,o,ag as n}from"./chunks/framework.BRWBV1zN.js";const p=JSON.parse('{"title":"Memoria de Control","description":"","frontmatter":{},"headers":[],"relativePath":"computer/cpu/control-memory.md","filePath":"computer/cpu/control-memory.md","lastUpdated":1756126032000}'),r={name:"computer/cpu/control-memory.md"};function c(t,a,s,l,u,d){return o(),i("div",null,a[0]||(a[0]=[n('<h1 id="memoria-de-control" tabindex="-1">Memoria de Control <a class="header-anchor" href="#memoria-de-control" aria-label="Permalink to &quot;Memoria de Control&quot;">​</a></h1><p>La memoria de control es un componente educativo que muestra cómo funciona internamente la unidad de control de la CPU. Permite visualizar las microinstrucciones y microoperaciones que se ejecutan para cada instrucción del programa.</p><h2 id="caracteristicas" tabindex="-1">Características <a class="header-anchor" href="#caracteristicas" aria-label="Permalink to &quot;Características&quot;">​</a></h2><h3 id="visualizacion-de-microprograma" tabindex="-1">Visualización de Microprograma <a class="header-anchor" href="#visualizacion-de-microprograma" aria-label="Permalink to &quot;Visualización de Microprograma&quot;">​</a></h3><ul><li><strong>Tabla de memoria de control</strong>: Muestra todas las instrucciones disponibles con sus respectivas microoperaciones</li><li><strong>Instrucción actual destacada</strong>: Resalta la instrucción que se está ejecutando actualmente</li><li><strong>Microoperaciones detalladas</strong>: Lista paso a paso las operaciones elementales de cada instrucción</li></ul><h3 id="animaciones-educativas" tabindex="-1">Animaciones Educativas <a class="header-anchor" href="#animaciones-educativas" aria-label="Permalink to &quot;Animaciones Educativas&quot;">​</a></h3><ul><li><strong>Entrada suave</strong>: El componente aparece con una animación de escala y opacidad</li><li><strong>Resaltado dinámico</strong>: La instrucción actual se resalta con un borde pulsante</li><li><strong>Interfaz intuitiva</strong>: Botón &quot;+&quot; en el decodificador para activar la visualización</li></ul><h3 id="contenido-educativo" tabindex="-1">Contenido Educativo <a class="header-anchor" href="#contenido-educativo" aria-label="Permalink to &quot;Contenido Educativo&quot;">​</a></h3><ul><li><strong>Descripciones</strong>: Cada instrucción incluye una explicación de su función</li><li><strong>Conceptos clave</strong>: Explicación de microinstrucciones, microoperaciones y secuencias</li><li><strong>Ejemplos prácticos</strong>: Microoperaciones realistas basadas en la arquitectura VonSim8</li></ul><h2 id="como-usar" tabindex="-1">Cómo usar <a class="header-anchor" href="#como-usar" aria-label="Permalink to &quot;Cómo usar&quot;">​</a></h2><ol><li><strong>Abrir la memoria de control</strong>: Haz clic en el botón &quot;+&quot; junto al decodificador en la unidad de control</li><li><strong>Ejecutar un programa</strong>: Carga y ejecuta un programa para ver las instrucciones en acción</li><li><strong>Observar las microoperaciones</strong>: La instrucción actual se resaltará automáticamente</li><li><strong>Cerrar la visualización</strong>: Haz clic fuera del modal o en el botón &quot;✕&quot;</li></ol><h2 id="microoperaciones-incluidas" tabindex="-1">Microoperaciones Incluidas <a class="header-anchor" href="#microoperaciones-incluidas" aria-label="Permalink to &quot;Microoperaciones Incluidas&quot;">​</a></h2><h3 id="instrucciones-de-transferencia-de-datos" tabindex="-1">Instrucciones de Transferencia de Datos <a class="header-anchor" href="#instrucciones-de-transferencia-de-datos" aria-label="Permalink to &quot;Instrucciones de Transferencia de Datos&quot;">​</a></h3><ul><li><strong>MOV</strong>: Transferencia entre registros y memoria</li><li><strong>PUSH/POP</strong>: Operaciones de pila</li></ul><h3 id="instrucciones-aritmeticas" tabindex="-1">Instrucciones Aritméticas <a class="header-anchor" href="#instrucciones-aritmeticas" aria-label="Permalink to &quot;Instrucciones Aritméticas&quot;">​</a></h3><ul><li><strong>ADD</strong>: Suma con actualización de flags</li><li><strong>SUB</strong>: Resta con actualización de flags</li><li><strong>CMP</strong>: Comparación sin modificar operandos</li></ul><h3 id="instrucciones-de-control-de-flujo" tabindex="-1">Instrucciones de Control de Flujo <a class="header-anchor" href="#instrucciones-de-control-de-flujo" aria-label="Permalink to &quot;Instrucciones de Control de Flujo&quot;">​</a></h3><ul><li><strong>JMP</strong>: Salto incondicional</li><li><strong>JZ/JNZ</strong>: Saltos condicionales</li><li><strong>CALL/RET</strong>: Llamadas a subrutinas</li></ul><h3 id="instrucciones-del-sistema" tabindex="-1">Instrucciones del Sistema <a class="header-anchor" href="#instrucciones-del-sistema" aria-label="Permalink to &quot;Instrucciones del Sistema&quot;">​</a></h3><ul><li><strong>HLT</strong>: Detener la CPU</li></ul><h2 id="conceptos-tecnicos" tabindex="-1">Conceptos Técnicos <a class="header-anchor" href="#conceptos-tecnicos" aria-label="Permalink to &quot;Conceptos Técnicos&quot;">​</a></h2><h3 id="microinstruccion" tabindex="-1">Microinstrucción <a class="header-anchor" href="#microinstruccion" aria-label="Permalink to &quot;Microinstrucción&quot;">​</a></h3><p>Una microinstrucción es un comando elemental que controla una microoperación específica dentro de la CPU. Por ejemplo, &quot;MAR←IP&quot; transfiere el contenido del registro IP al registro MAR.</p><h3 id="microoperacion" tabindex="-1">Microoperación <a class="header-anchor" href="#microoperacion" aria-label="Permalink to &quot;Microoperación&quot;">​</a></h3><p>Una microoperación es una operación atómica que se ejecuta en un solo ciclo de reloj. Ejemplos incluyen:</p><ul><li>Transferir datos entre registros</li><li>Leer/escribir memoria</li><li>Ejecutar operaciones en la ALU</li><li>Actualizar flags de estado</li></ul><h3 id="secuencia-de-microoperaciones" tabindex="-1">Secuencia de Microoperaciones <a class="header-anchor" href="#secuencia-de-microoperaciones" aria-label="Permalink to &quot;Secuencia de Microoperaciones&quot;">​</a></h3><p>Cada instrucción de máquina se ejecuta mediante una secuencia específica de microoperaciones. Esta secuencia está almacenada en la memoria de control y se accede mediante el código de operación de la instrucción.</p><h2 id="beneficios-educativos" tabindex="-1">Beneficios Educativos <a class="header-anchor" href="#beneficios-educativos" aria-label="Permalink to &quot;Beneficios Educativos&quot;">​</a></h2><ol><li><strong>Comprensión profunda</strong>: Ayuda a entender cómo las instrucciones de alto nivel se traducen en operaciones de bajo nivel</li><li><strong>Visualización clara</strong>: Muestra la relación entre instrucciones y microoperaciones de forma visual</li><li><strong>Aprendizaje interactivo</strong>: Permite experimentar con diferentes tipos de instrucciones</li><li><strong>Conceptos fundamentales</strong>: Introduce conceptos clave de arquitectura de computadoras</li></ol><h2 id="implementacion-tecnica" tabindex="-1">Implementación Técnica <a class="header-anchor" href="#implementacion-tecnica" aria-label="Permalink to &quot;Implementación Técnica&quot;">​</a></h2><p>La memoria de control está implementada como un componente React que:</p><ul><li>Utiliza react-spring para animaciones suaves</li><li>Se integra con el sistema de eventos de la CPU</li><li>Responde dinámicamente al estado de ejecución</li><li>Mantiene consistencia visual con el resto del simulador</li></ul>',33)]))}const h=e(r,[["render",c]]);export{p as __pageData,h as default};
